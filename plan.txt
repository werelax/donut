* 1. Decent reader
1b. Decent AST
2. Symbol/var assignment
3. Macro system

== Notes

- implement [] and {} as reader macros for (vec a b c) and (hash a b c)

- Data types:
  ! List -> Bad Idea! Difficult to fly close to JS with Lists
  + Vector
  + Hash/Object
  * String
  * Number
  * Symbol
  *? Keyword
  (so more or less just js data types)

== Decent reader:

* Programable? => Just transformations + recursive call to read
* delimiter: SPAC
* Should be an FSM?

== The LIST problem

* Using a non-js-native structure as the LIST is getting on the way of a clean, thin syntax wrapper over vainilla js.
* A lot of extrange cases are arising when the translation DONUT->JS is not so clear
* So I'm sending lists to hell and using arrays instead. DONUT LIST = JS array. And fuck it.
* Also, the syntax tree will be just nested arrays.

== The MACRO oddyssey

* Not idea of how to tacke this

** the macro:

(defmacro (akan :rest body)
  (list 'list (splice body)))

** compiles into ->

function macro_akan () {
  rest = Array.prototype.slice(arguments, 0);
  return ["list"].concat(splice(rest));
}

** so the AST node:

[akan 1 2 3]

** becomes:

macro_akan(1 2 3)

** and the AST is substitued with:

 ["list" 1 2 3]

** and then the compilation starts over again

* Lessons:

1) The defmacro definitions should be compiled+EVAL'D AS THE ARE READ
1.b) In a temporary JS context
1.c) If we want to use named functions inside the macros, we should COMPILE+EVAL
     all the named functions as we find them
1.d) I think I should just eval ALL the (DEFINE ...) forms for building an coherent
     temporal ENVIRONMENT for the macroexpansion
1.e) BEWARE!!!: The environments nest and the (DEFINE...) expressions can have very
     different meanings!! I don't see how to EVAL them correctly

2) When compiling, if we find some macro call, whe substitute the WHOLE NODE
   with the result OF EXECUTING the macro function!
2.b) Then we try to compile the AST node again, possible expanding another macro
     and starting all over again

3) In a way, the def_special_form() calls are very, very close to to this view of macros.
   The main difference is that the special_forms are already implemented as JS (and not aware
   of its environment).

* Strategy:

- Lets start without all the macro utilities. They are just noise for now.
- Define the most stupid macro imaginable, something like:

(defmacro forty-two () 42)

- And try to make all the machinery work just for substitute every call to (forty-two) with 42

== ENVIRONMENT BUILDING

* The evaluation-as-we-go of (DEFINE...) expressions has proven a to be bad approach.
* I'm thinking in something more sophisticated: code-walking the AST and simulating the
  environments as we go.
  - Each time we find a LAMBDA oR LET and descend into its childs, we create a new layer of
    "faked environment".
  - every (DEFINE) encountered is pseudo-compiled against the faked environment collected
  - the macros are expanded against this fake environment
  - when we pop out of the LET/LAMBDA node, the last layer of faked environment is deleted
