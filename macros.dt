(define
  read    (get :read    (require "./reader.js"))
  compile (get :compile (require "./compiler.js"))
  format  (get :format  (require "util")))

;; Inspect and modify scope

(define (create-scope? expr)
  (case (car expr)
    (("define" "let") true)
    (else false)))

(define (add-to-scope expr scope)
  (case (car expr)
    ("define" (add-define-to-scope expr scope))
    ("let" (add-let-to-scope expr scope)))
  expr)

(define (add-symbol-to-scope symbol value scope)
  (let ((current-scope (car scope)))
    (set! (get symbol current-scope) value)))

(define (add-define-to-scope expr scope)
  (let ((symbol (cadr expr))
        (value (walk-code (.slice expr 2))))
    (add-symbol-to-scope symbol (car value) scope)))

(define (add-let-to-scope expr scope)
  (let ((definitions (cadr expr))
        (body (.slice expr 2))
        ;; create new scope!
        (new-scope (cons {} scope)))
    (map (lambda (pair)
           (let ((symbol (car pair))
                 (value (walk-code (cdr pair))))
             (add-symbol-to-scope symbol (car value) new-scope)))
         definitions)
    (walk-code body new-scope)))

;; Scope evaluation context

(define (run-with-scope expr scope)
  (let ((scope-closure (build-scope scope)))
    (console.log (format scope-closure (compile expr)))))

;; (function(a,b) { (function(b,c) { %s })(3,4)})(1,2)
(define (build-scope scope)
  (let ((bindings (last scope)))
    (if bindings
      (let ((keys (get-keys bindings)))
        (let ((values (map (lambda (k) (compile (get k bindings)))
                           keys)))
          (format "(function(%s){ return %s })(%s)"
                  (.join keys ", ")
                  (build-scope (butlast scope))
                  (.join values ", "))))
      "%s")))

;; Macro expansion

(define (is-macroexpand? expr)
  (eq? (car expr) "defmacro"))

(define (expand-macro expr scope)
  (console.log (format "EXPANDING %j AS A MACRO!" expr))
  (console.log (format " ** SCOPE: %j" scope))
  (console.log "\n\n" (run-with-scope "YEAH!" scope) "\n\n"))

(define (walk-code ast (scope (list {})))
  (console.log (format "AST: %j" ast))
  ;; lets get to the thing!
  (let ((expr (car ast)))
    (if (not expr)
      '()
      (let ((next (cond
                    ((create-scope? expr) (add-to-scope expr scope))
                    ((is-macroexpand? expr) (expand-macro expr scope))
                    (else expr))))
        (cons next (walk-code (cdr ast) scope))))))

;; Just for testing (for now)

(let ((read-file (get :readFile (require "fs"))))
  (read-file (get 3 process.argv)
             "utf-8"
             (lambda (err data)
               (if err
                 (console.log err)
                 (console.log
                   (format "\nRESULT: %j" (walk-code (read data))))))))
