(define
  read    (get :read    (require "./reader.js"))
  compile (get :compile (require "./compiler.js"))
  gensym  (get :gensym  (require "./compiler.js"))
  format  (get :format  (require "util")))

;; Inspect and modify scope

(define (create-scope? expr)
  (case (car expr)
    (("define" "let") true)
    (else false)))

(define (add-to-scope expr scope)
  (case (car expr)
    ("define" (add-define-to-scope expr scope))
    ("let" (add-let-to-scope expr scope))))

(define (add-symbol-to-scope symbol value scope)
  (let ((current-scope (car scope)))
    (set! (get symbol current-scope) value)))

(define (add-define-to-scope expr scope)
  ;; TODO: Check if is a lambda!
  (let ((symbol (cadr expr))
        (value (car (walk-code (.slice expr 2)))))
    (add-symbol-to-scope symbol value scope)
    expr))

(define (add-let-to-scope expr scope)
  (let ((header (.slice expr 0 2))
        (definitions (cadr expr))
        (body (.slice expr 2))
        ;; create new scope!
        (new-scope (cons {} scope)))
    (console.log (format "LET BODY: %j" body))
    (map (lambda (pair)
           (let ((symbol (car pair))
                 (value (car (walk-code (cdr pair)))))
             (add-symbol-to-scope symbol value new-scope)))
         definitions)
    (.concat header (walk-code body new-scope))))

;; Scope evaluation context

(define (run-with-scope name expr scope)
  (let ((scope-closure (build-scope scope)))
    (format scope-closure name (compile expr))))

(define (build-scope scope)
  (let ((bindings (last scope)))
    (if bindings
      (let ((keys (get-keys bindings)))
        (let ((values (map (lambda (k) (compile (get k bindings)))
                           keys)))
          (format "(function(%s){ return %s; })(%s)"
                  (.join keys ", ")
                  (build-scope (butlast scope))
                  (.join values ", "))))
      "(%s = %s)")))

;; Macro definition

(define *macros* {})

(define (is-macro-definition? expr)
  (eq? (car expr) "defmacro"))

(define (create-macro expr scope)
  (let ((name (cadr expr))
        (args (caddr expr))
        (body (walk-code (cdddr expr) scope)))
    (console.log "BODY: " (walk-code (cdddr expr)))
    (let ((macro-function
           (compile (.concat '("lambda" args) body))))
      ;; XXX: DEBUG
      (console.log "\n\n==EXPANDED: " name "\n"
                   (run-with-scope name macro-function scope)
                   "\n==\n")
      ;; store the compiled-evaled macro-func in the global macro dictionary
      (set! (get name *macros*) (eval (run-with-scope name macro-function scope))))
    expr))

;; Macro expansion

(define (is-macro-expansion? expr)
  (some (lambda (macro)
          (eq? macro (car expr)))
        (get-keys *macros*)))

(define (expand-macro expr scope)
  (let ((name (car expr))
        (params (map eval ;; not sure about this EVAL!
                     (map compile
                          (cdr expr)))))
    (let ((macro (get name *macros*)))
      (let ((expansion (.apply macro {} params)))
        (let ((expanded-ast (car (walk-code
                                   (list expansion)
                                   scope))))
          (console.log "TRYING TO EXPAND: " name)
          (console.log (format "PARAMS: %j" params))
          (console.log "RESULT: " expansion)
          (console.log "RESULT AST: " expanded-ast)
          expanded-ast)))))

(define (walk-code ast (scope (list {})))
  (console.log (format " -> AST: %j" ast))
  ;; lets get to the thing!
  (if (null? ast)
    nil
    (let ((expr (car ast)))
      (let ((next (cond
                    ((create-scope? expr) (add-to-scope expr scope))
                    ((is-macro-definition? expr) (create-macro expr scope))
                    ((is-macro-expansion? expr) (expand-macro expr scope))
                    ((pair? expr) (cons (car expr)
                                        (walk-code (cdr expr) scope)))
                    (else expr)))
            (rest (walk-code (cdr ast) scope)))
        (console.log "XPR: " expr)
        (console.log "NEXT: " next "\n ")
        (cons next rest)))))

;; Just for testing (for now)

(let ((read-file (get :readFile (require "fs"))))
  (read-file (get 3 process.argv)
             "utf-8"
             (lambda (err data)
               (if err
                 (console.log err)
                 (let ((new-ast (walk-code (read data))))
                   (console.log "\n\n OLD AST: \n" (read data))
                   (console.log "\n New AST: \n" new-ast)
                   (console.log "\n\n ====== \n\n")
                   (console.log (compile new-ast)))))))
